Index: less/cmdbuf.c
diff -u less/cmdbuf.c:1.46 less/cmdbuf.c:1.47
--- less/cmdbuf.c:1.46	Sun Sep  4 23:36:22 2005
+++ less/cmdbuf.c	Fri Feb 24 23:28:33 2006
@@ -387,7 +387,7 @@
 		char *p;
 		int i, j;
 
-		multi_parse(mp, c, NULL_POSITION, &mbd);
+		multi_parse(mp, c, NULL_POSITION, &mbd, NULL);
 		i = mbd.byte;
 		if (i > 0)
 			for ((s = &cmdbuf[strlen_cs(cmdbuf, cmdcs)]),
Index: less/input.c
diff -u less/input.c:1.34 less/input.c:1.35
--- less/input.c:1.34	Sun Sep  4 23:36:22 2005
+++ less/input.c	Fri Feb 24 23:28:33 2006
@@ -59,6 +59,7 @@
 #if ISO
 	MULBUF* mp = get_mulbuf(curr_ifile);
 	M_BUFDATA mbd;
+	POSITION mpos;		/* buffered POSITION */
 	int ret;
 #endif
 
@@ -110,8 +111,8 @@
 		if (c == '\n' || c == EOI)
 		{
 #if ISO
-			multi_flush(mp, &mbd);
-			(void) pappend_multi(&mbd);
+			multi_flush(mp, &mbd, &mpos);
+			(void) pappend_multi(&mbd, &mpos);
 #endif
 			/*
 			 * End of the line.
@@ -125,8 +126,8 @@
 		 * Append the char to the line and get the next char.
 		 */
 #if ISO
-		multi_parse(mp, c, ch_tell()-1, &mbd);
-		ret = pappend_multi(&mbd);
+		multi_parse(mp, c, ch_tell()-1, &mbd, &mpos);
+		ret = pappend_multi(&mbd, &mpos);
 #else
 		ret = pappend(c, control_char(c) ? WRONGCS : ASCII, 1, ch_tell()-1);
 #endif
@@ -143,7 +144,8 @@
 				c = ch_forw_get();
 				while (c != '\n' && c != EOI)
 				{
-					multi_parse(mp, c, NULL_POSITION, NULL);
+					multi_parse(mp, c, NULL_POSITION,
+					    NULL, NULL);
 					c = ch_forw_get();
 				}
 				multi_discard(mp);
@@ -160,7 +162,7 @@
 			{
 #if ISO
 				multi_discard(mp);
-				new_pos = mbd.pos;
+				new_pos = mpos;
 #else
 				new_pos = ch_tell() - 1;
 #endif
@@ -210,6 +212,7 @@
 #if ISO
 	MULBUF* mp = get_mulbuf(curr_ifile);
 	M_BUFDATA mbd;
+	POSITION mpos;		/* buffered POSITION */
 	int ret;
 #endif
 
@@ -329,15 +332,15 @@
 		if (c == '\n')
 		{
 #if ISO
-			multi_flush(mp, &mbd);
-			(void) pappend_multi(&mbd);
+			multi_flush(mp, &mbd, &mpos);
+			(void) pappend_multi(&mbd, &mpos);
 #endif
 			endline = TRUE;
 			break;
 		}
 #if ISO
-		multi_parse(mp, c, ch_tell()-1, &mbd);
-		ret = pappend_multi(&mbd);
+		multi_parse(mp, c, ch_tell()-1, &mbd, &mpos);
+		ret = pappend_multi(&mbd, &mpos);
 #else
 		ret = pappend(c, control_char(c) ? WRONGCS : ASCII, 1, ch_tell()-1);
 #endif
@@ -359,7 +362,7 @@
 			}
 #if ISO
 			pdone(0);
-			ret = ch_tell() - mbd.pos;
+			ret = ch_tell() - mpos;
 			new_pos -= ret;
 			while (--ret >= 0)
 				ch_back_get();
Index: less/line.c
diff -u less/line.c:1.95 less/line.c:1.96
--- less/line.c:1.95	Tue Sep  6 07:27:57 2005
+++ less/line.c	Fri Feb 24 23:28:33 2006
@@ -619,13 +619,14 @@
  * Returns 0 if ok, 1 if couldn't fit in buffer.
  */
 	public int
-pappend_multi(mbd)
+pappend_multi(mbd, mpos)
 	M_BUFDATA *mbd;
+	POSITION *mpos;
 {
 	char *cbuf = mbd->cbuf;
 	CHARSET *csbuf = mbd->csbuf;
 	int byte = mbd->byte;
-	POSITION pos = mbd->pos;
+	POSITION pos = *mpos;
 	int r;
 	int saved_curr;
 	int saved_column;
Index: less/multi.c
diff -u less/multi.c:1.143 less/multi.c:1.145
--- less/multi.c:1.143	Fri Feb 24 02:17:10 2006
+++ less/multi.c	Fri Feb 24 23:28:33 2006
@@ -1639,7 +1639,7 @@
 	    while (lpos < pos) {
 		c = ch_forw_get();
 		assert(c != EOI && c != '\n');
-		multi_parse(mp, c, NULL_POSITION, NULL);
+		multi_parse(mp, c, NULL_POSITION, NULL, NULL);
 		lpos++;
 	    }
 	    ch_seek(pos);
@@ -1706,15 +1706,16 @@
 /*
  * Buffering characters untile get a guarantee that it is right sequence.
  */
-void multi_parse(mp, c, pos, mbd)
+void multi_parse(mp, c, pos, mbd, mpos)
 MULBUF* mp;
 int c;
 m_position pos;
 M_BUFDATA* mbd;
+POSITION* mpos;
 {
     if (c < 0) {
-	if (mbd != NULL) {
-	    mbd->pos = mp->startpos;
+	if (mpos != NULL) {
+	    *mpos = mp->startpos;
 	}
 	/*
 	 * Force to flush all buffering characters.
@@ -1744,8 +1745,8 @@
 	INBUF(mp) = c;
 
 	mp->laststartpos = mp->startpos;
-	if (mbd != NULL) {
-	    mbd->pos = mp->startpos;
+	if (mpos != NULL) {
+	    *mpos = mp->startpos;
 	}
 
 	/*
@@ -1765,11 +1766,12 @@
 /*
  * Flush buffered data.
  */
-void multi_flush(mp, mbd)
+void multi_flush(mp, mbd, mpos)
 MULBUF* mp;
 M_BUFDATA* mbd;
+POSITION* mpos;
 {
-    multi_parse(mp, -1, NULL_POSITION, mbd);
+    multi_parse(mp, -1, NULL_POSITION, mbd, mpos);
 }
 
 /*
@@ -1778,7 +1780,7 @@
 void multi_discard(mp)
 MULBUF* mp;
 {
-    multi_parse(mp, -1, NULL_POSITION, NULL);
+    multi_parse(mp, -1, NULL_POSITION, NULL, NULL);
 }
 
 void set_codesets(mp, input, inputr)
@@ -2069,6 +2071,11 @@
 		assert(cvindex == 2);
 		cvindex = 0;
 		cs = JISX0208KANJI;
+	} else if (cs == UTF8)
+	{
+		/* ? */
+		cvindex = 0;
+		return (nullcvbuffer);
 	} else
 	{
 		assert(0);
@@ -2158,6 +2165,11 @@
 		cvbuffer[3] = '\0';
 		cvindex = 0;
 		return (cvbuffer);
+	} else if (cs == UTF8)
+	{
+		/* ? */
+		cvindex = 0;
+		return (nullcvbuffer);
 	}
 	assert(0);
 	cvindex = 0;
@@ -2252,6 +2264,11 @@
 		cvbuffer[1] = c2 + (c2 >= 0x7f ? 1 : 0);
 		cvindex = 0;
 		return (cvbuffer);
+	} else if (cs == UTF8)
+	{
+		/* ? */
+		cvindex = 0;
+		return (nullcvbuffer);
 	}
 	assert(0);
 	cvindex = 0;
@@ -2301,6 +2318,11 @@
 	{
 		cvindex = 0;
 		return (cvbuffer);
+	} else if (cs == UTF8)
+	{
+		/* ? */
+		cvindex = 0;
+		return (nullcvbuffer);
 	}
 	assert(0);
 	cvindex = 0;
Index: less/multi.h
diff -u less/multi.h:1.29 less/multi.h:1.30
--- less/multi.h:1.29	Sat Feb 18 09:57:24 2006
+++ less/multi.h	Fri Feb 24 23:28:33 2006
@@ -349,7 +349,6 @@
 	char *cbuf;
 	CHARSET *csbuf;
 	int byte;
-	POSITION pos;
 } M_BUFDATA;
 
 /*
Index: less/search.c
diff -u less/search.c:1.63 less/search.c:1.64
--- less/search.c:1.63	Sun Sep  4 23:36:22 2005
+++ less/search.c	Fri Feb 24 23:28:33 2006
@@ -299,7 +299,7 @@
 				if (*src == '\0')
 				{
 					/* flush buffer */
-					multi_flush(mp, &mbd);
+					multi_flush(mp, &mbd, NULL);
 					cbuf = mbd.cbuf;
 					csbuf = mbd.csbuf;
 					bufcount = mbd.byte;
@@ -308,7 +308,7 @@
 				{
 					/* make charset */
 					multi_parse(mp, (unsigned char) *src,
-						pos, &mbd);
+						pos, &mbd, NULL);
 					cbuf = mbd.cbuf;
 					csbuf = mbd.csbuf;
 					bufcount = mbd.byte;
Index: less/version.c
diff -u less/version.c:1.111 less/version.c:1.113
--- less/version.c:1.111	Fri Feb 24 02:25:22 2006
+++ less/version.c	Fri Feb 24 23:36:47 2006
@@ -759,6 +759,13 @@
 iso261 2/24/06	Changed put_wrongmark function to make it work with new iso260
 		buffering semantics.  And applied a patch provied by Takuji.
 		Thanks to Takuji.
+iso262 2/24/06	Removed POSITION variable from member variables of M_BUFDATA.
+		It was added to make multi-byte character buffering function
+		work better with less.  However, it degraded abstraction level
+		of data structure (multi.h).  This time, add POSITION* as an
+		additional argument of few functions and keep data structure
+		as simple as possible.
+		This modification make regex_cs-lwp9k be able to compile.
 */
 
-char version[] = "382+iso261";
+char version[] = "382+iso262";
